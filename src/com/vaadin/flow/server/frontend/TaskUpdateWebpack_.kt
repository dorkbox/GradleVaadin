package com.vaadin.flow.server.frontend

import dorkbox.gradleVaadin.CustomClassFinder
import dorkbox.gradleVaadin.node.NodeInfo
import java.io.FileOutputStream


/**
 * flow-server-2.8.3
 */
object TaskUpdateWebpack_ {
    fun execute(nodeInfo: NodeInfo, customClassFinder: CustomClassFinder) {
        // NOTE: we do not use the default TaskUpdateWebpack execution, because there are some changes we have to make
        //  so we copy/modify it

        // If we have an old config file we remove it and create the new one
        // using the webpack.generated.js
        val configFile = nodeInfo.origWebPackFile

        if (configFile.exists()) {
            if (!FrontendUtils.isWebpackConfigFile(configFile)) {
                Util.logger.warn(
                    "Flow generated webpack configuration was not mentioned "
                            + "in the configuration file: {}."
                            + "Please verify that './webpack.generated.js' is used "
                            + "in the merge or remove the file to generate a new one.",
                    configFile
                )
            }
        } else {
            // DO NOT copy the file from vaadin, copy our own file (since we customize where node_modules is located)
            this.javaClass.classLoader.getResource("webpack.config.js")?.openStream().use {
                if (it != null) {
                    nodeInfo.origWebPackFile.apply {
                        it.copyTo(FileOutputStream(this))
                        println("\t\tCreated webpack config configuration file: $this")
                    }
                }
            }

            this.javaClass.classLoader.getResource("webpack.config.js")?.openStream().use {
                if (it != null) {
                    nodeInfo.origWebPackProdFile.apply {
                        it.copyTo(FileOutputStream(this))
                        println("\t\tCreated webpack production configuration file: $this")
                    }
                }
            }
        }

        Util.compareAndCopy(nodeInfo.origWebPackFile, nodeInfo.webPackFile)
        Util.compareAndCopy(nodeInfo.origWebPackProdFile, nodeInfo.webPackProdFile)



        // Generated file is always re-written
        val generatedFile = nodeInfo.webPackGeneratedFile
        println("\tUpdating generated webpack file: $generatedFile")


        val resource = customClassFinder.getResource(FrontendUtils.WEBPACK_GENERATED)
        resource?.openStream()?.copyTo(FileOutputStream(generatedFile))

        // NOTE: Matches are trimmed!
        //  path.resolve(__dirname .... __dirname is the '/build' dir
        val replacements = mutableListOf<Pair<String, String>>()

        replacements.add(Pair(" * This file has been generated by the `flow:prepare-frontend` maven goal",
                              " * This file has been generated by the Vaadin `updateWebPack` gradle task."))

        // absolute path source frontend dir
        val dirWebpack = Util.universalPath(nodeInfo.frontendSourceDir_WebPack)
        replacements.add(Pair("const frontendFolder =",
                              "const frontendFolder = '$dirWebpack';"))

        // This *MUST* be the source frontend dir, RELATIVE to the GENERATED frontend directory!
        val frontendFolder = Util.relativize(nodeInfo.frontendDestDir_WebPack, nodeInfo.frontendSourceDir_WebPack)
        replacements.add(Pair("Frontend: frontendFolder",
                              "        Frontend: '$frontendFolder'"))


        // 'frontend/generated-flow-imports.js'
        val flowImportFile = Util.universalPath(nodeInfo.flowImportFile)
        replacements.add(Pair("const fileNameOfTheFlowGeneratedMainEntryPoint =",
                              "const fileNameOfTheFlowGeneratedMainEntryPoint = '$flowImportFile';"))



        // '../resources/META-INF/resources/VAADIN'
        val vaadinDir = Util.universalPath(nodeInfo.vaadinDir)
        replacements.add(Pair("const mavenOutputFolderForFlowBundledFiles =",
                              "const mavenOutputFolderForFlowBundledFiles = '$vaadinDir';"))


        replacements.add(Pair("const devmodeGizmoJS =",
                              "const devmodeGizmoJS = '" + FrontendUtils.DEVMODE_GIZMO_MODULE + "'"))


        // NOTE: new stuff. Change 'src/main/webapp' -> 'webapp' (or META-INF? which is where all static resources are served...)
        val sourceMetaInfDir = Util.universalPath(nodeInfo.metaInfDir)
        replacements.add(Pair("contentBase: [mavenOutputFolderForFlowBundledFiles,",
                              "    contentBase: [mavenOutputFolderForFlowBundledFiles, '$sourceMetaInfDir'],"))


        // This *MUST* be the source frontend dir, RELATIVE to the GENERATED frontend directory!
        val flowFrontendDir =  Util.universalPath(nodeInfo.frontendGeneratedDir)
        replacements.add(Pair("const flowFrontendFolder",
                              "const flowFrontendFolder = '$flowFrontendDir'"))

        // This *MUST* be the source frontend dir, RELATIVE to the GENERATED frontend directory!
        val resourcesDir =  Util.universalPath(nodeInfo.vaadinStaticDir)
        replacements.add(Pair("const projectStaticAssetsOutputFolder",
                              "const projectStaticAssetsOutputFolder = '$resourcesDir'"))


        val lines = generatedFile.readLines(Charsets.UTF_8).toMutableList()
        for (i in lines.indices) {
            val line = lines[i].trim()

            val hasReplacement = replacements.firstOrNull { line.startsWith(it.first) }
            if (hasReplacement != null) {
                replacements.removeIf { it == hasReplacement } // only do a SINGLE replacement for this entry.
                lines[i] = hasReplacement.second
            }
        }

        // always have unix!
        generatedFile.writeText(lines.joinToString(separator = "\n"))
    }
}
